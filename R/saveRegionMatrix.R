#' Save a region count matrix
#'
#' Count the number of fragment start/end positions within user-defined genomic regions, using the fragment file generated by Cellranger.
#' Then, save the resulting matrix into a HDF5 file.
#'
#' @param fragment.file String containing a path to a fragment file.
#' @param output.file String containing a path to an output HDF5 file.
#' If none exists, one will be created.
#' @param output.name String containing the name of the group inside \code{output.file}, in which to save the matrix contents.
#' @param regions A \linkS4class{GRanges} or \linkS4class{GRangesList} of the regions in which to count fragments.
#' If \code{regions} is a GRangesList, the count for each entry of \code{regions} will include all fragment starts/ends falling in any of the genomic intervals in its GRanges.
#' @param barcodes Character vector of cell barcodes to extract, e.g., based on the filtered cells reported by Cellranger.
#' If \code{NULL}, all barcodes are extracted, though this is usually undesirable as not all barcodes correspond to cell-containing droplets.
#' @param chunk.dim Integer scalar specifying the size of the chunks (in terms of the number of elements) inside the HDF5 file.
#' @param compress.level Integer scalar specifying the Zlib compression level to use.
#'
#' @details
#' We count the overlap with the start/end positions of each fragment, not the overlap with the fragment interval itself.
#' This is because the fragment start/ends represent the transposase cleavage events, while the fragment interval has no real biological significance.
#'
#' If a fragment start/end overlaps with multiple entries of \code{regions}, it is not counted as the assignment is ambiguous.
#' This should not be confused with overlaps to multiple intervals of the same entry when \code{regions} is a GRangesList;
#' this yields a mapping to a single feature, even if the exact interval isnot  ambiguous.
#'
#' If the start and end for the same fragment overlap different entries of \code{regions}, the counts for both entries are incremented by 1. 
#' This reflects the fact that these positions represent distinct transposase cleavage events for different features.
#' However, if the start and end for the same fragment overlap the same entry of \code{regions}, the entry's count is only incremented by 1. 
#' This ensures that the count for each entry of \code{regions} still follows Poisson noise and avoids an artificial enrichment of even counts. 
#'
#' @return A sparse matrix is saved to \code{output.file} using the 10X HDF5 format.
#' A \linkS4class{H5SparseMatrix} referencing this file is returned where the rows correspond to entries of \code{regions}.
#' Column names are set to the cell barcodes - if \code{barcodes} is supplied, this is directly used as the column names.
#'
#' @author Aaron Lun
#' @examples
#' # Mocking up the fragment file.
#' seq.lengths <- c(chrA = 2000, chrB = 10000)
#' temp <- tempfile(fileext = ".gz")
#' mockFragmentFile(temp, seq.lengths, 1e3, cell.names = LETTERS)
#'
#' # Mocking up some regions of interest.
#' library(GenomicRanges)
#' regions <- GRanges(c("chrA:500-1000", "chrB:1000-2000"))
#'
#' # Running the counter
#' out <- tempfile(fileext=".h5")
#' counts <- saveRegionMatrix(temp, output.file=out, output.name="WHEE", regions=regions)
#' counts
#'
#' @export
#' @importFrom utils read.delim
#' @importFrom rhdf5 h5createFile h5createGroup
#' @importFrom HDF5Array H5SparseMatrix
saveRegionMatrix <- function(fragment.file, output.file, output.name, regions, barcodes=NULL, compress.level = 6, chunk.dim = 20000) {
    if (!file.exists(output.file)) {
        h5createFile(output.file)
    }
    h5createGroup(output.file, output.name)

    sanitized <- .sanitizeRegions(regions)

    output <- fragments_to_regions(
        fragment_file = fragment.file,
        output_file = output.file, 
        output_group = output.name, 
        seqnames = names(sanitized$ids), 
        num_regions = length(regions),
        region_ids = sanitized$ids,
        region_starts = sanitized$starts,
        region_ends = sanitized$ends,
        cellnames = barcodes,
        deflate_level = compress.level,
        chunk_dim = chunk.dim
    )

    obs <- H5SparseMatrix(output.file, output.name)
    if (is.null(barcodes)) {
        barcodes <- output
    }
    colnames(obs) <- barcodes

    obs
}

#' @import methods
#' @importFrom GenomeInfoDb seqnames
#' @importFrom BiocGenerics setdiff start end
#' @importFrom IRanges reduce coverage slice findOverlaps
#' @importClassesFrom GenomicRanges GRanges 
.sanitizeRegions <- function(regions, decompose = TRUE) { 
    if (is(regions, "GRangesList")) {
        regions <- reduce(regions, ignore.strand=TRUE) # eliminating overlaps within each GRanges
    }
    solo <- as(slice(coverage(regions), lower=1, upper=1), "GRanges") # only considering intervals with coverage of exactly 1. 
    overlap <- findOverlaps(solo, regions, select="first")

    if (!decompose) {
        return(list(regions = solo, ids = overlap))
    }

    seqnames <- as.character(seqnames(solo))
    by_ids <- split(overlap - 1L, seqnames) # get to 0-based indices
    starts <- split(start(solo) - 1L, seqnames) # get to 0-based starts.
    ends <- split(end(solo), seqnames) # leave as open ends.

    for (s in names(by_ids)) {
        o <- order(starts[[s]])
        starts[[s]] <- starts[[s]][o]
        ends[[s]] <- ends[[s]][o]
        by_ids[[s]] <- by_ids[[s]][o]
    }

    list(
        ids = by_ids, 
        starts = starts, 
        ends = ends
    )
}
