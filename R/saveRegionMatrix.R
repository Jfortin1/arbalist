#' Save a region count matrix
#'
#' Count the number of fragment start/end positions within user-defined genomic regions, using the fragment file generated by Cellranger.
#' Then, save the resulting matrix into a HDF5 file.
#'
#' @param fragment.file String containing a path to a fragment file.
#' @param output.file String containing a path to an output HDF5 file.
#' If none exists, one will be created.
#' @param output.name String containing the name of the group inside \code{output.file}, in which to save the matrix contents.
#' @param regions A \linkS4class{GRanges} or \linkS4class{GRangesList} of the regions in which to count fragments.
#' For a GRangesList, each GRanges is treated as a separate feature and will count all fragment starts/ends falling in any of its intervals.
#' @param barcodes Character vector of cell barcodes to extract, e.g., based on the filtered cells reported by Cellranger.
#' If \code{NULL}, all barcodes are extracted, though this is usually undesirable as not all barcodes correspond to cell-containing droplets.
#' @param chunk.dim Integer scalar specifying the size of the chunks (in terms of the number of elements) inside the HDF5 file.
#' @param compress.level Integer scalar specifying the Zlib compression level to use.
#'
#' @return A sparse matrix is saved to \code{output.file} using the 10X HDF5 format.
#' A \linkS4class{H5SparseMatrix} referencing this file is returned where the rows correspond to entries of \code{regions}.
#' Column names are set to the cell barcodes - if \code{barcodes} is supplied, this is directly used as the column names.
#'
#' @author Aaron Lun
#'
#' @export
#' @importFrom utils read.delim
#' @importFrom rhdf5 h5createFile h5createGroup
#' @importFrom HDF5Array H5SparseMatrix
saveRegionMatrix <- function(fragment.file, output.file, output.name, regions, barcodes=NULL, compress.level = 6, chunk.dim = 20000) {
    if (!file.exists(output.file)) {
        h5createFile(output.file)
    }
    h5createGroup(output.file, output.name)

    sanitized <- sanitize_regions(regions)

    output <- fragments_to_regions(
        fragment_file = fragment.file,
        output_file = output.file, 
        output_group = output.name, 
        seqnames = names(sanitized$ids), 
        num_regions = length(regions),
        region_ids = sanitized$ids,
        region_starts = sanitized$starts,
        region_ends = sanitized$ends,
        cellnames = barcodes,
        deflate_level = compress.level,
        chunk_dim = chunk.dim
    )

    obs <- H5SparseMatrix(output.file, output.name)
    if (is.null(barcodes)) {
        barcodes <- output
    }
    colnames(obs) <- barcodes

    obs
}

#' @import methods
#' @importFrom GenomeInfoDb seqnames
#' @importFrom BiocGenerics setdiff
#' @importFrom IRanges reduce coverage slice findOverlaps
#' @importClassesFrom GenomicRanges GRanges 
sanitize_regions <- function(regions, decompose = TRUE) { 
    if (is(regions, "GRangesList")) {
        regions <- reduce(regions, ignore.strand=TRUE) # eliminating overlaps within each GRanges
    }
    solo <- as(slice(coverage(regions), lower=1, upper=1), "GRanges") # only considering intervals with coverage of exactly 1. 
    overlap <- findOverlaps(solo, regions, select="first")

    if (!decompose) {
        return(list(regions = solo, ids = overlap))
    }

    seqnames <- as.character(seqnames(solo))
    by_ids <- split(overlap - 1L, seqnames) # get to 0-based indices
    starts <- split(start(solo) - 1L, seqnames) # get to 0-based starts.
    ends <- split(end(solo), seqnames) # leave as open ends.

    for (s in names(by_ids)) {
        o <- order(starts[[s]])
        starts[[s]] <- starts[[s]][o]
        ends[[s]] <- ends[[s]][o]
        by_ids[[s]] <- by_ids[[s]][o]
    }

    list(
        ids = by_ids, 
        starts = starts, 
        ends = ends
    )
}
