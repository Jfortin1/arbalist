#' Save a tile count matrix
#'
#' Count the number of fragment start/end positions within genomic tiles for each cell, using the fragment file generated by Cellranger.
#' Then, save the resulting matrix into a HDF5 file.
#'
#' @param fragment.file String containing a path to a fragment file.
#' @param output.file String containing a path to an output HDF5 file.
#' If none exists, one will be created.
#' @param output.name String containing the name of the group inside \code{output.file}, in which to save the matrix contents.
#' @param seq.lengths Named integer vector containing the lengths of the reference sequences used for alignment.
#' Vector names should correspond to the names of the sequences, in the same order of occurrence as in the fragment file.
#' If \code{NULL}, this is obtained from the reference genome used by Cellranger (itself located by scanning the header of the fragment file).
#' @param barcodes Character vector of cell barcodes to extract, e.g., based on the filtered cells reported by Cellranger.
#' If \code{NULL}, all barcodes are extracted, though this is usually undesirable as not all barcodes correspond to cell-containing droplets.
#' @param tile.size Integer scalar specifying the size of the tiles in base pairs.
#' @param chunk.dim Integer scalar specifying the size of the chunks (in terms of the number of elements) inside the HDF5 file.
#' @param compress.level Integer scalar specifying the Zlib compression level to use.
#'
#' @return A sparse matrix is saved to \code{output.file} using the 10X HDF5 format.
#' If \code{cell.names=NULL}, a character vector is invisibly returned, containing the cell barcodes corresponding to the columns of the matrix.
#' Otherwise, \code{NULL} is invisibly returned.
#' 
#' @author Aaron Lun
#'
#' @export
#' @importFrom utils read.delim
#' @importFrom rhdf5 h5createFile h5createGroup
saveTileMatrix <- function(fragment.file, output.file, output.name, seq.lengths=NULL, barcodes=NULL, tile.size = 500, compress.level = 6, chunk.dim = 20000) {
    if (is.null(seq.lengths)) {
        # Obtaining the sequence lengths, if they weren't already available.
        info <- .process_fragment_header(fragment.file)
        fai <- file.path(info$reference_path, "fasta", "genome.fa.fai")
        fai.info <- read.delim(fai, sep="\t", header=FALSE)[,1:2]
        seq.lengths <- fai.info[,2]
        names(seq.lengths) <- fai.info[,1]
    }

    if (!file.exists(output.file)) {
        h5createFile(output.file)
    }
    h5createGroup(output.file, output.name)

    output <- dump_fragments_to_files(
        fragment_file = fragment.file,
        tile_size = tile.size, 
        output_file = output.file, 
        output_group = output.name, 
        seqlengths = seq.lengths, 
        seqnames = names(seq.lengths), 
        cellnames = barcodes,
        deflate_level = compress.level,
        chunk_dim = chunk.dim
    )

    invisible(output)
}

.process_fragment_header <- function(file) {
    handle <- gzfile(file, open="rb")
    on.exit(close(handle))
    all.headers <- character(0)

    chunk <- 100
    repeat {
        lines <- readLines(handle, n = chunk)
        header <- startsWith(lines, "#")
        all.headers <- c(all.headers, sub("^# ", lines[header]))
        if (length(lines) < n || !all(header)) {
            break
        }
    }

    field <- sub("=.*", "", all.headers)
    value <- sub("[^=]+=", all.headers)
    split(value, field)
}
