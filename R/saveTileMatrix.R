#' Save a tile count matrix
#'
#' Count the number of fragment start/end positions within genomic tiles for each cell, using the fragment file generated by Cellranger.
#' Then, save the resulting matrix into a HDF5 file.
#'
#' @param fragment.file String containing a path to a fragment file.
#' @param output.file String containing a path to an output HDF5 file.
#' If none exists, one will be created.
#' @param output.name String containing the name of the group inside \code{output.file}, in which to save the matrix contents.
#' @param seq.lengths Named integer vector containing the lengths of the reference sequences used for alignment.
#' Vector names should correspond to the names of the sequences, in the same order of occurrence as in the fragment file.
#' If \code{NULL}, this is obtained from the reference genome used by Cellranger (itself located by scanning the header of the fragment file).
#' @param barcodes Character vector of cell barcodes to extract, e.g., based on the filtered cells reported by Cellranger.
#' If \code{NULL}, all barcodes are extracted, though this is usually undesirable as not all barcodes correspond to cell-containing droplets.
#' @param tile.size Integer scalar specifying the size of the tiles in base pairs.
#' @param chunk.dim Integer scalar specifying the size of the chunks (in terms of the number of elements) inside the HDF5 file.
#' @param compress.level Integer scalar specifying the Zlib compression level to use.
#'
#' @details
#' We count the overlap with the start/end positions of each fragment, not the overlap with the fragment interval itself.
#' This is because the fragment start/ends represent the transposase cleavage events, while the fragment interval has no real biological significance.
#'
#' If the start and end for the same fragment overlap different tiles, the counts for both tiles are incremented by 1. 
#' This reflects the fact that these positions represent distinct transposase cleavage events for different features.
#' However, if the start and end for the same fragment overlap the same tile, the tile's count is only incremented by 1. 
#' This ensures that the count for each entry of \code{regions} still follows Poisson noise and avoids an artificial enrichment of even counts. 
#'
#' @return A sparse matrix is saved to \code{output.file} using the 10X HDF5 format.
#' A list is returned containing:
#' \itemize{
#' \item \code{tiles}, a GRanges object containing the tile coordinates.
#' \item \code{counts} A \linkS4class{H5SparseMatrix} referencing the \code{outputfile}, where the rows correspond to entries of \code{tiles}.
#' Column names are set to the cell barcodes - if \code{barcodes} is supplied, this is directly used as the column names.
#' }
#' 
#' @author Aaron Lun
#' @examples
#' # Mocking up the fragment file.
#' seq.lengths <- c(chrA = 2000, chrB = 10000)
#' temp <- tempfile(fileext = ".gz")
#' mockFragmentFile(temp, seq.lengths, 1e3, cell.names = LETTERS)
#'
#' # Running the counter
#' out <- tempfile(fileext=".h5")
#' counted <- saveTileMatrix(temp, output.file=out, output.name="WHEE", seq.lengths=seq.lengths)
#' counted
#'
#' @export
#' @importFrom utils read.delim
#' @importFrom rhdf5 h5createFile h5createGroup
#' @importFrom HDF5Array H5SparseMatrix
#' @importFrom GenomicRanges GRanges
#' @importFrom GenomeInfoDb Seqinfo
#' @importFrom IRanges IRanges
saveTileMatrix <- function(fragment.file, output.file, output.name, seq.lengths=NULL, barcodes=NULL, tile.size = 500, compress.level = 6, chunk.dim = 20000) {
    if (is.null(seq.lengths)) {
        # Obtaining the sequence lengths, if they weren't already available.
        info <- .process_fragment_header(fragment.file)
        fai <- file.path(info$reference_path, "fasta", "genome.fa.fai")
        fai.info <- read.delim(fai, sep="\t", header=FALSE)[,1:2]
        seq.lengths <- fai.info[,2]
        names(seq.lengths) <- fai.info[,1]
    }

    if (!file.exists(output.file)) {
        h5createFile(output.file)
    }
    h5createGroup(output.file, output.name)

    output <- fragments_to_tiles(
        fragment_file = fragment.file,
        tile_size = tile.size, 
        output_file = output.file, 
        output_group = output.name, 
        seqlengths = seq.lengths, 
        seqnames = names(seq.lengths), 
        cellnames = barcodes,
        deflate_level = compress.level,
        chunk_dim = chunk.dim
    )

    nbins <- ceiling(seq.lengths / tile.size)
    seqs <- rep(names(seq.lengths), nbins)
    ends <- sequence(nbins) * tile.size
    starts <- ends - tile.size + 1L
    ends <- pmin(ends, rep(seq.lengths, nbins))
    tiles <- GRanges(seqs, IRanges(starts, ends), seqinfo=Seqinfo(names(seq.lengths), seq.lengths))

    counts <- H5SparseMatrix(output.file, output.name)
    if (is.null(barcodes)) {
        barcodes <- output
    }
    colnames(counts) <- barcodes

    list(tiles = tiles, counts = counts)
}

.process_fragment_header <- function(file) {
    handle <- gzfile(file, open="rb")
    on.exit(close(handle))
    all.headers <- character(0)

    chunk <- 100
    repeat {
        lines <- readLines(handle, n = chunk)
        header <- startsWith(lines, "#")
        all.headers <- c(all.headers, sub("^# ", "", lines[header]))
        if (length(lines) < chunk || !all(header)) {
            break
        }
    }

    field <- sub("=.*", "", all.headers)
    value <- sub("[^=]+=", "", all.headers)
    split(value, field)
}
