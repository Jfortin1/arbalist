% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/initializeSparseMatrix.R
\name{initializeCpp}
\alias{initializeCpp}
\alias{initializeCpp,dgCMatrix-method}
\alias{initializeCpp,dgRMatrix-method}
\alias{initializeCpp,H5SparseMatrixSeed-method}
\alias{flushFileBasedCache}
\title{Initialize the matrix in C++ memory space}
\usage{
initializeCpp(x, force.integer = TRUE, ...)
}
\arguments{
\item{x}{A sparse matrix-like object, typically from the \pkg{Matrix} or \pkg{HDF5Array} packages.
Alternatively, a \link{DelayedArray} wrapper around such objects.}

\item{force.integer}{Logical scalar indicating whether double-precision \code{x} should be forced into integers.
Only used for loading a HDF5-backed matrix into memory.}
}
\value{
An external pointer to a C++ object containing a tatami matrix.
}
\description{
Initialize a tatami matrix object in C++ memory space from an in-memory or HDF5-backed sparse matrix, or any DelayedArray derivatives thereof. 
This object simply references the R memory space and avoids making any copies of its own, so it can be cheaply re-created when needed inside each function.
}
\details{
Do not attempt to serialize this object; it contains a pointer to external memory, and will not be valid after a save/load cycle.
Users should not be exposed to the returned pointers; rather, each \pkg{arbalest} function should call \code{initializeCpp} at the start to obtain a C++ object for further processing.
As mentioned before, this initialization process is very cheap so there is no downside from just recreating the object within each function body.

The HDF5-backed sparse matrix is fully loaded into C++ memory upon initialization, to avoid the performance hit from constantly querying the file system.
Obviously, this is a rather time-consuming process, so to maintain the cheapness of this function, we use a global cache to store the pointer returned by the first initialization of any HDF5-backed \code{x}.
Subsequent calls to this function will then re-use the cached pointer.
If the process is using too much memory, users can flush the cache by calling \code{flushFileBackedCache()}.
}
\examples{
# Mocking up a count matrix:
x <- Matrix::rsparsematrix(1000, 100, 0.1)
y <- round(abs(x))

stuff <- initializeCpp(y)
str(stuff)


}
